---
title: U3剩余 数据更新、空值的处理、视图
date: 2019-08-17 15:03:19
categories: 幽邃研路
tags: [考研,人大855,数据库]
---
这里的数据更新指的是对于表中数据的增删改三个操作  
#### 3.5.1 插入数据
- 插入单个元组
- 插入子查询结果（从而插入多个元组）  
##### 1. 插入单个元组
###### 语句格式：
<!--more--> 
```
INSERT INTO <表名> [(<属性列1> [,<属性列2>]...)]  
VALUES (<常量1>,[<常量2>])  
```
说明：  
属性列和下方常量的位置是一一对应的，没写的属性列自动置为NULL。  
若INSERT语句中没写属性列名，默认全列填充，**且此时属性列的顺序与建表时候的顺序完全相同**，并且可以直接在对应的列上赋上空值    
**VALUES子句里面字符串常数要用单引号括起来**  
##### 2. 插入子查询结果
###### 语句格式：  
INSERT INTO <表名> [(<属性列1> [,<属性列2>]...)]  
子查询；

#### 3.5.2 修改数据
###### 语句格式：
```
UPDATE <表名>  
SET <列名>=<表达式> [,<列名>=<表达式>]...  
[WHERE <条件>]  
```
###### 分类：  
- 修改一个元组
- 修改多个元组
- 带子查询的修改语句（只能放在WHERE里）
   
SET子句后面可以放入子查询，不过必须返回单值  
#### 3.5.3 删除数据
###### 语法格式：
```
DELETE FROM <表名> [WHERE <条件>]
```
**DELETE语句删除的是表的数据，而不是表的定义**。就算一张表的全部数据都被删除，表的定义还在数据库的数据字典里面  
###### 分类：  
- 删除一个元组
- 删除多个元组
    - 不写WHERE条件就是全删
- 带子查询的删除语句
    - 子查询用于构造删除条件  

### 3.6 空值的处理
空值不是0，**空值是“不知道”，“不存在”或者“无意义”的值**  
**空值是一个很特殊的值，含有不确定性**  
1. 空值的产生
    - 插入，直接修改，外连接，空值的关系运算都会产生空值
2. 空值的判断
    - 判断方法：**IS NULL/IS NOT NULL**
3. 空值的约束条件
    - 属性定义（或域定义）中有NOT NULL约束条件的不能取空值，加了UNIQUE约束条件限制的属性不能取空值，码属性不能取空值
4. 空值的算术运算、比较运算和逻辑运算
    - 空值与另一个值的算术运算结果为空值
    - 空值与另一个值的比较运算结果为**UNKNOWN**
    - 有了UNKNOWN之后，传统的逻辑运算中二值逻辑就扩展为三值逻辑
    - 在查询语句中，只有使WHERE和HAVING子句中的选择条件为TRUE的元组才能作为输出结果  

### 3.7 视图
视图是从一个或几个基本表（视图）中导出的虚表，数据库里面只会存储视图的定义，但不会存视图的数据。基本表中数据改变，视图的数据就跟着改变  
#### 3.7.1 定义视图
##### 1. 建立视图
###### 定义语句：  
```
CREATE VIEW <视图名> [(<列名> [,<列名>]...]  
AS <子查询>
[WITH CHECK OPTION]
```
###### 说明：  
1. WITH CHECK OPTION表示：对于视图进行增、删、改操作的时候，要保证增、删、改操作的行满足视图定义的谓词条件（就是子查询中的条件表达式）（**判断还是直接修改？？**）（都有）  
（视图就是一个窗口，子查询规定死了这个窗口所能看到的东西，因此如果你想修改这个窗口，应该也保证修改符合这个窗口本身的限制，而这个人为制造的窗口，它的限制是通过人为的WHERE子句之类的条件表达式固定的）  
（我通过子查询所找到的数据构成了这个窗口，窗口里展示的数据就应该符合子查询的条件（被子查询能找到））  

2. 组成视图的属性列名只能**全部省略或者全部指定**  
    - 这个全部省略或者指定说的意思是不要上边指定一部分，下边SELECT再写一部分
3. 如果省略，则视图展示的所有字段由SELECT子句中的字段构成
4. 在下列三种情况下，必须指定所有列名
    - 某个属性列不是单纯的属性名，而是聚集函数或者表达式
    - 多表连接是选出了几个同名列作为视图的字段
    - 需要在视图中为某个列启用新的更合适的名字
5. CREAT VIEW语句执行后**只是把视图的定义存入数据字典，并不执行其中的SELECT语句**  

例子：  
```
CREATE VIEW IS_Student
AS
SELECT Sno,Sname,Sage
FROM Student
WHERE Sdept='IS'
WITH CHECK OPTION
```
由于有WITH CHECK OPTION子句，对数据库数据进行增删改的时候，DBMS**会自动加上Sdept='IS'的条件**  

**行列子集视图**：从单个基本表导出，并且只是去掉了基本表中的某些行和某些列，但保留了主码  

视图还可以建立在一个或者多个已定义好的视图上，或者基本表和视图上  

定义基本表时候，只存储基本数据，但是由于视图中的数据并不存储，可以在视图中存放一些经过计算得到的派生属性列，他们并不真实存在，因此又称为虚拟列。**带虚拟列的视图又称为带表达式的视图**  
例子：
```
CREATE VIEW BT_S(Sno,Sname,Sbirth)
AS
SELECT Sno,Sname,2019-Sage
FROM Students;
```

**分组视图**：使用带有聚集函数和GROUP BY子句的查询来定义视图  
例子：  
```
CREATE VIEW S_G(Sno,Gavg)
AS
SELECT Sno,AVG(Grade)
FROM SC
GROUP BY Sno;
```
##### 2. 删除视图
###### 语句格式：
```
DROP VIEW <视图名> [CASCADE]
```
说明：
- CASCADE:级联删除
- 删除的是定义
- 基本表删除之后，视图只是没法用，而没被删除  

#### 3.7.2 查询视图
查询视图的时候，用法和基本表一样  
###### 查询过程：  
DBMS执行对视图的查询时，首先进行有效性检查，看查询中涉及的表和视图是否存在，若存在，**则从数据字典中取出对视图的定义，吧定义中的子查询和用户的查询结合起来，转换为等价的对基本表的查询，然后再执行修正了的查询，这一过程称为视图消解**  
即为：  
```
graph TD
对视图和基本表进行有效性检查-->从数据字典取出视图定义
从数据字典取出视图定义-->将视图定义中子查询和用户的查询结合
将视图定义中子查询和用户的查询结合-->转换为等价的对基本表的查询
转换为等价的对基本表的查询-->执行修正后查询
```
###### 视图消解可能失败：
例子：  
```
SELECT *
FROM S_G
WHERE Gavg>=90
```
而S_G为：
```
SELECT Sno,AVG(Grade)
FROM SC
GROUP BY Sno;
```
则有可能产生的消解结果为：  
```
SELECT Sno,AVG(Grade)
FROM SC
WHERE AVG(Grade)>=90
GROUP BY Sno;
```
这个消解结果就是错误的，因为WHERE中出现了聚集函数  
正确转换的语句应为：  
```
SELECT Sno,AVG(Grade)
FROM SC
GROUP BY Sno
HAVING AVG(Grade)>=90
```
**目前多数关系数据库系统对行列子集视图的查询均能正确转换。但对非行列子集视图的查询就不一定能做转换了**  
上边这个例子的查询也可以使用派生表进行  
但是，**定义视图并查询视图与基于派生表的查询是有区别的。派生表只是在语句执行的时候临时定义，语句执行之后该定义即被删除**  
#### 3.7.3 更新视图
更新视图是指通过视图来增删改数据  
**由于视图是不存在的虚表，因此对视图的更新最终要转换为对基本表的更新**  
（走的是视图消解）  

转换的时候通常会带着等价替换，填充等  

**并不是所有的视图都是可更新的**  
例子：  
```
UPDATE S_G
SET Gavg=90
WHERE Sno='201631043'
```
这个视图的更新不能那个唯一有意义的转变为对基本表的更新。因为Gavg是一个动态计算的1东西，他是一个视图，而不是一张表，Gavg代表的是一个AVG函数，而不是表的某一列  
S_G视图是不可更新的  

**一般来说，行列子集视图是可更新的。各个系统对于视图的更新还有进一步的规定，系统不同，规定不同**  

**不可更新的视图和不允许更新的视图是两个概念，后者可能可以更新**  

#### 3.7.4 视图的作用
1. 视图能够简化用户的操作
2. 视图使用户能够以多种角度看待同一数据
3. 视图对重构数据库提供了一定程度上的逻辑独立性
    - 例如，如果我们重构数据库，将原来一个大表裂解为两个小表，我们就可以建立一个和原来的大表结构相同的视图，使得不用修改应用程序
    - **尽管数据库的逻辑结构改变了，但应用程序不用修改，因为新建立的视图定义为用户原来的的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据**  
    - 一定程度指的是，当对数据进行修改的时候，视图可能无法修改，这是对应用程序要修改  
4. 视图可以对机密数据提供安全保护
5. 适当利用视图可以更清晰的表达查询