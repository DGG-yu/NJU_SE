---
title: 3.4 数据查询
date: 2019-08-17 15:03:10
categories: 幽邃研路
tags: [考研,人大855,数据库]
---
#### 3.4.1 单表查询
##### 1. 选择表中的若干列
1. 查询指定列
    - 这就是关系代数中的投影运算
    - SELECT <列名> FROM <表名>
    - 逐元组抽取目标属性上的值组成新关系
    - 语句中的列名顺序和表中顺序可以不同
<!--more--> 
2. 查询全部列
    - SELECT 全部列名
    - SELECT *
3. 查询经过计算的值
    - Select子句中的目标列表达式可以是表中的属性列也可以是表达式
    - 表达式可以是算术表达式，也可以是字符串常量、函数等
        - 字符串常量的话，查询结果的每一行，在该列上都是该字符串常量
    - 某个列后边加空格，可以指定别名
        - select sname, sage-11 Birthday, cno  
##### 2. 选择表中的若干元组
1. 取消取值重复的行
    - 用DISTINCT
    - 如果没有写DISTINCT，默认为ALL，即保留取值重复的行
2. 查询满足条件的元组
    - WHERE子句
    - 查询条件 | 谓词
        ---|---
        比较 | =, >, <, >=, <=, !=, <>, !>, !<; NOT+上述运算符
        确定范围 | BETWEEN AND, NOT BETWEEN AND
        确定集合 | IN, NOT IN
        字符匹配 | LIKE, NOT LIKE
        空值 | IS NULL, IS NOT NULL
        多重条件（逻辑运算） | AND, OR, NOT
###### 比较运算：
- Sdept = 'CS'，可能为逐元组扫描比较，成功则生成新元组  
- age < 30  
###### 确定范围：
WHERE 列名 BETWEEN 下限 AND 上限  
###### 确定集合：
WHERE 列名 IN （集合）
（这个IN的集合是一个散点的集合，而BET AND 是连续集合）  
###### 字符匹配：
- 语法格式：[NOT] LIKE'<匹配串>' [ESCAPE'<换码字符>']
- 查找指定的属性列值与匹配串相匹配的元组
    - %代表任意长度的字符串
    - _代表任意单个字符
若LIKE后面的字符串不含通配符，则可以用=代替LIKE，用!=代替NOT LIKE  
若要查询的字符串中本身含有通配符的符号，则利用ESCAPE <换码字符>来处理：  
```
例：查询DB_design课程的课程号：  
SELECT Cno  
FROM Cousre
WHERE Cname LIKE 'DB\_course' ESCAPE '\'  
```
这里，'\'被处理成了转码字符，因此紧跟在、后面的_不会被视为通配符  
###### 涉及空值的查询
IS NULL不可以用'='代替  
###### 多重条件查询
AND优先级高于OR，但是可以用()改变优先级关系  
IN相当于很多OR的缩写  

##### 3. ORDER BY子句
ORDER BY子句可以对于查询结果按照一个或者多个属性列进行排序，默认为升序  
**对于空值，排序是显示的次序由具体实现来决定，各个系统的实现可以不同，只要保持一致就行**  
##### 4. 聚集函数

函数 | 功能
---|---
COUNT(*) | 统计元组个数
COUNT([DISTINCT|ALL]<列名>) | 统计一列中值的个数
SUM([DISTINCT|ALL]<列名>) | 计算一列值的总和（该列必须是数值型）
AVG([DISTINCT|ALL]<列名>) | 计算一列数值的平均值
MAX([DISTINCT|ALL]<列名>) | 求一列值中的最大值
MIN([DISTINCT|ALL]<列名>) | 求一列值中的最小值

若指定DISTINCT，则**计算时**要取消选中列的重复值  

**当聚集函数遇到空值时，除COUNT(星)以外，都跳过空值而只处理非空值**

WHERE字句不能用聚集函数，聚集函数只能用于SELECT子句或HAVING子句中  

##### 5. GROUP BY子句
GROUP BY子句按照一个或者多个列的值进行分组，值相等的为一组  
**分组后聚焦函数将作用于每一组，即每一组都有一个函数值**，查询结果分组的目的就是细化聚焦函数作用的对象    
在GROUP BY中使用HAVING子句可以对于分出的组进行筛选  

#### 3.4.2 连接查询
##### 1. 等值和非等值连接查询
连接查询中WHERE子句中用来连接两个表的条件称为**连接条件**或者**连接谓词**  
连接谓词还可以采用：  
表名.列名 BETWEEN 表名.列名 AND 表名.列名  
等值连接：连接运算符为‘=’，其他运算符为非等值连接  
**连接谓词中的列名为连接字段，各连接字段类型必须是可比的**  

例子：Student.SNO=SC.SNO  
执行该连接操作的一种可能性为：从Stu表中找出第一个元组，然后遍历SC表，由此，遍历完Stu表。**这就是嵌套循环连接算法的基本思想**  
当使用索引时，**可以根据Sno值通过索引找到相应的SC元组，用索引查询SC中满足条件的元组一般会比全表扫描快**  
**若在等值连接中，把目标列中重复的属性列去掉则为自然连接**  
（之前学的是在关系模型中定义的概念，现在这个是在SQL中的具体实现）  
一条SQL语句可以同时完成选择和连接查询，**这时WHERE子句是由选择谓词和连接谓词组成的复合条件**  

例子：  
SELECT Stu.sno,Sname  
FROM Stu,SC  
WHERE Stu.Sno=SC.Sno AND SC.Cno='2' AND SC.Grade>90  

这个查询的一种优化的执行过程是，先从SC中筛选出Cno=2且Grade>90的元组形成一个种间关系，在和Stu中的元组进行连接  

##### 2. 自身连接
一个表与其自己可以连接，称为表的自身连接  
自身连接的时候要给表取别名  
##### 3. 外连接
若连接某表时，想要**把悬浮元组保留在结果关系中时**  
左外连接和右外连接  
（课本中使用[LEFT|RIGHT] OUTER JOIN来表示外连接）  

##### 4. 多表连接
上述都是双表连接、一个表与自己连接，多表连接指>=3张表  
DBMS一般都是先连接其中两张表，然后把结果与第三张表进行连接  
#### 3.4.3 嵌套查询  
在SQL中，**一个SELECT-FROM-WHERE 语句成为一个查询块**，将一个查询块嵌套在另外一个查询块的**WHERE子句**或者**HAVING短语**的条件中的查询称为**嵌套查询**  

例子：  
```
SELECT Sname  
FROM Student  
WHERE Sno IN  
(SELECT Sno FROM SC WHERE Cno='2');
```
上层查询块称为外层查询或者父查询，下层查询块称为内层查询或者子查询  

子查询中不能使用ORDER BY子句，ORDER BY子句只能用于对于最终结果进行排序  

意义：**嵌套查询使得用户可以用多个简单查询构成复杂的查询。以层层嵌套的方式来构造程序正是SQL中“结构化”的含义所在**  

查询分类：  
- **不相关子查询**    
    - 定义：子查询的查询条件不依赖于父查询，则为不相关  
    - 处理方法：由里向外，先执行子查询，子查询的结果用于建立其父查询的查找条件  
- **相关子查询**
    - 定义：如果子查询的查询条件依赖于父查询，这类子查询称为相关子查询
    - 整个查询语句称为**相关嵌套查询语句**
    - 处理方法：从父查询中抽出一个元组，放入子查询中作为查询条件，子查询完成查询之后，返回结果作为父查询的查询条件，父查询把该元组拿来跑这个查询，得到查询结果，然后取出下一个元组执行该步骤  
    - 如果对于不同的元组，我们进行处理的集合也随之不同，就用相关子查询

**有的嵌套查询可以用连接运算替代，有的不能替代**  
##### 1. 带有IN谓词的子查询  
在嵌套查询中，子查询的结果往往是一个集合，所以谓词IN是嵌套查询中最常使用的的谓词  
##### 2. 带有比较运算符的子查询
指父查询和子查询之间用比较运算符进行连接，此时内层查询返回的是单个值  
##### 3. 带有ANY(SOME)或ALL谓词的子查询
子查询返回多值时，可以用ANY（SOME）或者ALL  
- ANY表示某一个值
- ALL表示任何一个值
然后和比较运算符的意义组合起来，就是最终意思了  

在使用的时候，这个查询可以同义转换成其他查询  
例子：找出非CS系中年龄小于CS系中任何一个学生的学生  
实现法一：先子查询，找出CS系中所有学生的年龄所构成的集合，而后用>ANY  
法二：小于任何一个-->小于最大值即可，因此先找出CS系中年龄最大值，然后查询小于最大值的元组  

对前两段总结：ANY/ALL与聚集函数MAX//MIN以及谓词IN/NOT IN根据要求（即><的不同）有不同的对应关系  

##### 4. 带有EXIST谓词的子查询
EXISTS代表存在量词。**带有EXISTS的子查询不反悔任何数据，只产生逻辑真值”true“或逻辑假值”false“**  
利用EXISTS可以判断：  

```math
x\in R \ \ \ \ S\subseteq R \ \ \ \ S=R \ \ \ \ S\cap R\neq \varnothing 
```
使用EXISTS后，若内层结果非空则WHERE返回真值，若为空则返回假值  
带有EXISTS的相关子查询是在父查询中逐个抽取元组根据返回值进行比较（那么普通的呢？？）  

所有带IN, 比较运算符，ANY/ALL的子查询都能够用带EXISTS谓词的子查询等价替换  

###### 通过EXISTS 与N E可以处理全称量词查询问题
一个全称量词，如“学生x选修了全部课程”，转换为以下这个查询被否定。这个查询就是：存在课程y，x没有选修y。   
没有选修-->not exists  
命题本身否定-->not exists  
我们要的就是内层命题的判断结果而已也就是找出这样的学生，对本命题判断结果最终为true    
```
select *  
from student s  
where not exists   
(  
select *  
from course c  
where not exists  
(  
select *  
from transcript t  
where s.id = t.studid and c.crscode = t.crscode  
)  
) 
```
###### 逻辑蕴含查询问题
逻辑蕴含需要通过谓词演算进行转化，将其转化成存在量词加上交并补的形式  

#### 3.4.4 集合查询
SELECT操作的结果是集合，因此对于多个SELECT的结果，可以进行集合操作  
分类：  
- UNION 并操作
    - UNION会对结果自动去重，使用UNION ALL可以避免
- INTERSECT 交操作
    - 既……又……，貌似很多时候可以用AND来等价  
- EXCEPT 差操作

参加集合操作的各个查询结果其列数和数据类型必须相同  

#### 3.4.5 基于派生表的查询
子查询不仅可以出现在WHERE子句中，还可以出现在FROM子句中，这是子查询生成的临时派生表成为父查询的查询对象  

子查询没有聚集函数的话就不用为子表指定列名了（直接用AS在里面指明不行吗？）。指定列名就是：SELECT AVG(A1),BALABALA... AS ZITAB(AVG_A1,BALABALA...)  
派生表必须有名字  