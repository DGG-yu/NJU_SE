---
title: 第九单元 关系查询处理和关系优化
date: 2019-09-09 15:03:10
categories: 幽邃研路
tags: [考研,人大855,数据库]
---
本章介绍查询处理和查询优化，查询优化是查询处理的一部分，查询优化分为代数优化（逻辑优化）和物理优化（非代数优化）。  
代数优化优化的是关系代数表达式，物理优化是通过存取路径和底层操作算法的选择进行的优化  
### 9.1 关系数据库系统的查询处理
查询处理：DBMS的执行的查询语句的过程，将用户提交的从查询语句转换为搞笑的**查询执行计划**  
#### 9.1.1 查询处理步骤
##### 1. 查询分析
- 对于查询语句进行扫描、词法分析和语法分析。判断查询语句是否符合语法规则。  
##### 2. 查询检查
<!--more--> 
- 对于合法的查询语句进行语义检查，即根据数据字典中有关的模式定义检查语句中的数据库对象，如关系名、属性名是否存在和有效。  
- 如果有对视图的操作，就进行视图的消解。
- 根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查。  
- **这时的完整性检查是初步的、静态的检查**
- 所有检查通过后，就把查询语句转换为等价的**关系代数表达式**（这个是内部表示）
- 生成关系代数表达式时：
    - 把数据库对象的外部名称转换为内部表示
    - DBMS一般都用查询书（语法分析树）来表示拓展的关系代数表达式

##### 3. 查询优化
含义：每个查询都会有许多可供选择的执行策略和操作算法，查询优化就是选择一个最高效的处理策略  
分类：按照优化的层次：  
- 代数优化
    - 指对关系代数表达式的优化
    - 详细：按照一定的规则，通过对关系代数表达式进行等价变换，改变代数表达式中的操作和组合，使得查询执行更加高效
- 物理优化
    - 指存取路径和底层操作算法的选择
    - 选择的依据：
        - 基于规则
        - 基于代价
        - 基于语义

实际上查询优化器是综合运用这些技术的  

##### 4. 查询执行
依据优化器得到的执行策略生成查询执行计划，由**代码生成器**生成执行这个查询计划的代码，然后加以执行，回送查询执行结果  

查询检查-->查询树    
查询优化-->查询执行计划  

#### 9.1.2 实现查询操作的算法示例
本节简单介绍选择操作和连接操作的实现算法的思想。  
每种操作都有多个实现算法，这里就说说最主要的  

##### 1. 选择操作的实现
选择操作只涉及一个关系，通常采用全表扫描或者基于索引的方法  
###### 1. 简单的全表扫描方法
假设可以使用的内存有M块  
基本思想：  
1. 按照物理次序读取Student表的M块到内存
2. 检查内存的每个元组t，如果t满足选择条件，则输出t 
3. 如果Student表还有其他块没有处理，重复以上步骤
特点：  
- 只需要很少的内存（>=1块）就可以运行
- 控制简单
- 对于规模较小的表，这种算法简单有效，对于规模大的表进行顺序扫描，当选择率较低时，这种算法效率较低  

###### 2. 索引扫描的算法
前提：如果选择条件中的属性上有索引（如hush或者B+树），可用索引扫描方法  
过程：通过索引先找到满足条件的元组指针，再通过元组指针在查询的基本表中找到元组  

这里需要区分select操作的条件  
- C1:无条件
- C2:Sno=201212121
- C3:Sage>20
- c4:Sdept=CS AND Sage>20

例子：  
1. C2：如果在Sno上有索引，就可以使用索引查找学号为201212121的元组的指针，从而得到元组
2. C3：如果在Sage上有B+树索引，首先通过B+树索引找到Sage=20的索引项，然后以此为入口点在B+树的顺序集上找到所有>20的元组指针
3. C4：C4有两种实现方式  
    - 如果在两个属性上都有索引，根据Sdept条件和Sage条件，按照C3的方法，分别找出两个指针集合，然后求两个指针集的交集，再回表中检索
    - 先找到Sdept=CS的一组元组指针，通过这些指针到表中进行检索，并对得到的元组检查另一些选择条件是否满足，把满足条件的元组作为结果输出

两种算法比较：  
- 当选择率较低时，基于索引的算法要优于全表扫描算法
- 当选择率较高，或者要查找的远祖均匀的分布在要查找的表中，全表扫描优于基于索引

原因：除了对表的扫描操作，还要加上对B+树索引的扫描操作  

##### 2. 连接操作的实现
**连接操作是查询处理中最常用也是最耗时的操作之一**  
等值连接最常用的几种算法如下： 
###### 1. 嵌套循环算法
- 特点
    - **最简单可行**
    - 可以处理包括非等值连接在内的各种连接操作
- 思想：对外层循环的每一个元组，检索内层循环中的每一个元组，检查这两个远足在连接属性上是否相等。如果满足连接条件，则串接后作为结果输出  
- 在实际实现的时候是按照数据库读入内存的，而不是按照元组进行I/O的  

###### 2. 排序-合并算法
- 特点：**这是等值连接常用的算法，尤其适合参与连接的诸表已经排好序的情况**  
- 算法步骤：
    1. 如果参与连接的表没有排好序，首先对表都按照连接属性进行排序
    2. 取表1的第一个远足，依次扫描表2中具有相同属性值的元组，把它们连接起来
    3. 当扫描到表2的不相同的第一个元组是，返回表1扫描它的下一个元组，再去扫描表2中具有相同属性值的元组，把他们连接起来

最后两张表都只扫描了一边，对于大表会节省时间  

###### 3. 索引连接算法
算法步骤：
1. 在表1上对于连接属性建立索引
2. 对于表2中的每一个元组，根据其属性值，通过表1的索引查找出相应的表1中的元组
3. 将这些元组连接起来
循环执行2.3，直至表2中的元组都被处理完  

###### 4. hash join算法
也是处理等值连接的算
算法思想：  
1. **划分阶段**（创建阶段）
    - 创建hash表，对于较小的表进行一遍处理，把他的元组按照hash函数（连接属性作为hash码）分散到hash表的桶中
2. **试探阶段**（连接阶段）
    - 对于另一个表进行一遍处理，把他的每一个元组也按同一个hash函数进行散列，找到适当的hash桶，并把表2的元组与同重来自表1并与之匹配的元组连接起来  

算法前提：两个表中较小的表在第一阶段过后可以完全放入内存的hash桶中

### 9.2 关系数据库系统的查询优化
意义：关系查询优化是影响关系DBMS性能的关键因素，也是关系数系统的优点所在    

#### 9.2.1 查询优化概述
查询优化的优点：  
1. **用户不必考虑如何最好的表达查询以获得较高的效率**
    - 在非关系系统中，用户必须了解存取路径，系统必须提供用户选择存取路径的手段，查询效率有用户的存取策略决定，若用户做了不当选择，系统无法改进（总而言之就是，系统在优化方面啥都不管，而且非常死板）  
2. **系统可以比用户程序的”优化“做得更好**
    - 原因：
        1. 优化器可以从数据字典中获取许多统计信息，根据这些信息做出正确的估算，选出搞笑的执行计划，而用户程序难以获得这些信息
        2. 如果数据库的物理统计信息改变了，系统可以自动对查询进行重新优化已选择相适应的执行计划，而非关系系统中则必须重写程序
        3. 优化器可以考虑数百种不同的执行计划，而程序员一般只考虑有限的几种
        4. 优化器中包含了很多往往只有最好的程序员才能掌握的复杂的优化技术。系统的自动优化相当于所有人都拥有了

**在集中式数据库中，查询执行开销主要包括磁盘存取块数（I/O代价）、处理机时间（CPU代价）以及查询的内存开销**  
总代价=I\O代价+CPU代价+内存开销(+通讯代价)（分布式数据库中才有）  
**计算查询代价时，一般用查询处理读写的块数作为衡量单位**  

代数优化是对于关系代数表达式进行重组和选择，而物理优化则是对于优化结果中的某一个具体操作，如连接操作，选择操作，选择一个高效的算法以及存取路径  

### 9.3 代数优化
代数优化是基于关系代数等价变换规则的优化方法。  
#### 9.3.1 关系代数表达式等价变换规则
**代数优化策略是通过对关系代数表达式的等价变换来提高查询效率**  
对于两个关系代数表达式，若使用相同的关系代替其中相应的关系进行运算所得到的结果相同，则两个表达式等价 

##### 1. 连接、笛卡儿积具有交换律和结合律
##### 2. 投影的串接定律
- 前提是外面投影出的属性列是内部投影的属性列的子集
##### 3. 选择的串接定律
- 就是内外两个选择可以直接转换成并运算
##### 4. 选择和投影操作具有交换律
##### 5。 选择和笛卡儿积具有交换律 
- 意义是使得部分选择在笛卡儿积之前做
##### 6. 选择和并的分配律
##### 7. 选择和查询运算具有分配律
##### 8. 选择和自然连接的分配律
##### 9. 投影和笛卡儿积的分配律
##### 10. 投影和并集的分配律

#### 9.3.2 查询树的启发式优化
本节讨论基于启发式规则的代数优化，这是对查询书进行优化的方法，典型启发式规则如下：  
1. **选择运算尽可能先做**
2. **投影运算和选择运算同时进行**
3. **把投影同期前或者后的双目运算符结合起来**
4. **把某些选择同在他前面要执行的笛卡尔积结合起来成为一个连接运算**
5. **找出公共子表达式**


运用方法：  
1. 把并集条件拆分为多个单独的条件
2. 对每一个选择，尽力移到树的叶端
3. 对每一个投影，尽力移到树的叶端
4. 把选择和投影的串接合并成单个选择、单个投影或一个选择后接一个投影（先选后投）  
5. 把上述得到的语法树进行分组，每一个双目运算和她所有的直接祖先为一组，如果其后代直到叶子都是单目运算，则将企业并入该组，担当双目运算是笛卡儿积，而后面不是和他组成等值连接的选择时，不能把选择和这个双目运算组成同一组？？？啥意思     

### 9.4 物理优化
---
代数优化改变查询语句中操作的次序和组合，但不涉及底层的存取路径  
对于每一种操作都有多种执行该操作的算法，有多条存取路径，因此对于一个查询语句，有多种存取方案  
物理优化就是选择高校合理的操作算法或存取路径，球的优化的查询计划。  

选择方法分为三种：  
1. 基于规则的启发式优化   
2. 基于代价估算的优化
3. 两者结合的优化方法
    - 由于可能的策略过多，优化器不可能一一穷尽，否则会造成优化的代价大于所得的益处
    - 因此常常先用启发式规则，选出多种较优的方案，然后分别计算这些方案的执行代价，总而较快的选出最优方案  

#### 9.4.1 基于启发式规则的存取路径选择优化  
##### 1. 选择操作的启发式规则
对于小关系，即使选择列上有索引，也直接全表顺序扫描  
对于大关系启发式规则为：  
1. 对于选择条件是“主码=值”的查询，由于查询结果最多是一个元组，可以选择主码索引，一般的惯性系DBMS会自动建立主码索引  
2. 对于选择条件是“非主属性=值”的查询，并且选择列上有索引，则估算查询结果的元组数目，如果比例较小（<10%），就可以使用索引扫描方法，否则还是使用全表顺序扫描  
3. 对于选择条件是属性上的非等值查询或者范围查询，并且选择列上有索引，处理方法同2
4. 对于用AND连接的合取选择条件，如果有涉及这些属性的组合索引，则优先采用组合索引扫描方法，如果某些属性上有一般索引，则可以使用上方C4的方法，否则，全表顺序扫描
5. 对于用OR连接的析取选择条件，一般使用全表顺序扫描  

##### 2. 连接操作的启发式规则
1. 如果两个表都已经按照连接属性排序，则选用排序-合并算法
2. 如果一个表在连接属性上有索引，则可以使用索引连接算法
3. 如果1，2都不适用，但其中一个表较小，可以使用hash join算法
4. 最后可以使用嵌套循环算法，并选择其中**占用的块数较小**的表，作为外循环的表  
    - 理由：  
设连接表R与S分别占用的块数为Br与Bs，连接操作使用的内存缓冲区块数为K，分配K-1块给外表，如果R为外表，则嵌套循环法存取的块数为:  
Br+ (Br/(K-1)) *Bs
显然应该选块数小的表作为外表 
（把块数当成元组数，并认为内存每次执行内循环都要对于内表完全读取，因此，首先外循环要把外表读取一次，而后外表所占块数除以内存所分配给他的缓冲区大小，就是循环执行的次数，也就是内表要被读取的次数，第一次循环或第一次读取已经包括在内了，最终读取块数如上）  

#### 9.4.2 基于代价估算的优化
特点：  
- 启发式规则
    - 启发式规则优化是定性的选择，比较粗糙
    - 实现简单，本身的代价较小
    - 适合解释执行的系统，因为其优化开销包含在查询总开销之中
- 代价估算
    - 可用于编译执行的系统
    - 因其一次编译，多次执行，查询优化和查询执行是分开的
##### 1. 统计信息
基于代价优化的方法要计算各种操作算法的执行代价，而这与数据库的状态密切相关，为此在数据字典中存储了优化器所需的统计信息，包括以下方面：  
1. 对于每个基本表，该表的元组总数，元组长度，占用的块数，占用的溢出块数  ，
2. 对于本表的每个列，该列的最大值，最小值，该列上是否建立了索引，是那种索引（B+,hash,聚集索引）。根据这些统计信息，可以计算出谓词条件的选择率，如果不同值的分布是均匀的，f=1/m，如果不通知的分布不均匀，则要计算每个值的选择率，f=具有该值的元组数/N
3. 对于索引，例如B+树索引，记录该索引的层数，不同索引值的个数，索引的叶节点数，索引的选择基数    
##### 2. 代价估算示例
###### 1. 全表扫描算法的代价估算公式
如果基本表大小为B块，全表扫描算法的代价 cost＝B  
如果选择条件是码＝值，那么平均搜索代价 cost＝B/2  
###### 2. 索引扫描算法的代价估算公式
1. 如果选择条件是码＝值，如［例1-C2］，则采用该表的主索引，若主索引为B+树，层数为L，需要存取B+树中从根结点到叶结点L块，再加上基本表中该元组所在的那一块，所以cost=L+1
2. 如果选择条件涉及非码属性，如［例1-C3］，若为B+树索引，选择条件是相等比较，设S是索引的选择基数(有S个元组满足条件)
最坏的情况下，满足条件的元组可能会保存在不同的块上，此时，cost=L+S
3. 如果比较条件是＞，＞＝，＜，＜＝操作，假设有一半的元组满足条件就要存取一半的叶结点，通过索引访问一半的表存储块cost=L+Y(索引的叶节点数)/2+B(基本表的存取块数)/2  
###### 3. 嵌套循环连接算法的代价估算公式
9.4.1中已经讨论过了嵌套循环连接算法的代价：cost＝Br+(Br/(K-1))*Bs，  
如果需要把连接结果写回磁盘，  
cost＝Br+(Br/(K-1))*Bs +(Frs*Nr*Ns)/Mrs  
其中Frs为连接选择性(join selectivity)，表示连接结果元组数的比例  
Mrs是存放连接结果的块因子，表示每块中可以存放的结果元组数目。

###### 4. 排序-合并连接算法的代价估算公式
如果连接表已经按照连接属性排好序，则：cost＝Br+Bs+(Frs*Nr*Ns)/Mrs。  
如果必须对文件排序，需要在代价函数中加上排序的代价，对于包含B个块的文件排序的代价大约是(2*B)+(2*B*log2B)。